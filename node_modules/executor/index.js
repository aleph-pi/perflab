#!/usr/bin/env node

'use strict';

var spawn = require('child_process').spawn,
	Promise = require('bluebird'),
	fs = Promise.promisifyAll(require('fs-extra')),
	EventEmitter = require('events');

class Executor extends EventEmitter {

	constructor() {
		super();

		var depPath = '.';

		this._depPath = (path) => {
			var old = depPath;
			depPath = path;
			return old;
		};

		this._target = (stage, prev, action) => {
			this[stage] = () => {
				var guard = `${depPath}/.dep/${stage}`;
				if (fs.existsSync(guard)) {
					return Promise.resolve();
				} else {
					var before = prev ? this[prev].bind(this) : Promise.resolve;
					var task = () => {
						this.emit('targetStart', stage);
						return action();
					};
					var after = () => {
						this.emit('targetFinish', stage);
						return stage === "run" ? Promise.resolve() : fs.outputFileAsync(guard, '');
					};
					return before().then(task).then(after);
				}
			}
		}

		var nonl = (d) => {
			return ('' + d).replace(/\n$/, '');
		}

		this._run = (cmd, args, opts) => {
			console.log(cmd + ' ' + args.join(' '));
			return new Promise((resolve, reject) => {
				var stdout = '', stderr = '';
				var child = spawn(cmd, args, opts);
				child.stdout.on('data', (data) => {
					stdout += data;
					this.emit('stdout', nonl(data));
				});
				child.stderr.on('data', (data) => {
					stderr += data
					this.emit('stderr', nonl(data));
				});
				child.on('exit', (status) => {
					if (status) {
						reject({stdout, stderr, status});
					} else {
						resolve({stdout, stderr});
					}
				});
			});
		}

		this._runWatch = (cmd, args, opts, match) => {
			console.log(cmd + ' ' + args.join(' '));
			return new Promise((resolve, reject) => {
				var matched = false;
				var stdout = '', stderr = '';
				var child = spawn(cmd, args, opts);
				child.stdout.on('data', (data) => {
					stdout += data;
					this.emit('stdout', nonl(data));
				});
				child.stderr.on('data', (data) => {
					stderr += data;
					this.emit('stderr', nonl(data));
					if (!matched && stderr.match(match)) {
						matched = true;
						resolve({stdout, stderr});
					}
				});
				child.on('exit', (status) => {
					if (matched) {
						// do nothing
					} else {
						reject({stdout, stderr, status});
					}
				});
			});
		}
	}
}

module.exports = Executor;
